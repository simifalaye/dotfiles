-- MiniDeps.add({
--   source = "rmagatti/auto-session",
-- })
--
-- MiniDeps.now(function()
--   -- Set session options
--   vim.o.sessionoptions =
--     "blank,buffers,curdir,folds,help,tabpages,winsize,winpos,terminal,localoptions"
--
--   -- Load plugin
--   local autosession = require("auto-session")
--   local first_restore = true
--   autosession.setup({
--     -- Saving / restoring
--     enabled = true, -- Enables/disables auto creating, saving and restoring
--     auto_save = true, -- Enables/disables auto saving session on exit
--     auto_restore = true, -- Enables/disables auto restoring session on start
--     auto_create = function()
--       local cmd = "git rev-parse --show-cdup"
--       return vim.fn.system(cmd) == "\n"
--     end, -- Enables/disables auto creating new session files. Can be a function that returns true if a new session file should be allowed
--     auto_restore_last_session = false, -- On startup, loads the last saved session if session for cwd does not exist
--     cwd_change_handling = true, -- Automatically save/restore sessions when changing directories
--     single_session_mode = false, -- Enable single session mode to keep all work in one session regardless of cwd changes. When enabled, prevents creation of separate sessions for different directories and maintains one unified session. Does not work with cwd_change_handling
--
--     -- Filtering
--     suppressed_dirs = nil, -- Suppress session restore/create in certain directories
--     allowed_dirs = nil, -- Allow session restore/create in certain directories
--     bypass_save_filetypes = nil, -- List of filetypes to bypass auto save when the only buffer open is one of the file types listed, useful to ignore dashboards
--     close_filetypes_on_save = { "checkhealth" }, -- Buffers with matching filetypes will be closed before saving
--     close_unsupported_windows = true, -- Close windows that aren't backed by normal file before autosaving a session
--     preserve_buffer_on_restore = function(bufnr)
--       local ft = vim.api.nvim_get_option_value("filetype", { buf = bufnr })
--       local bt = vim.api.nvim_get_option_value("buftype", { buf = bufnr })
--       local name = vim.api.nvim_buf_get_name(bufnr)
--       if name == "" and ft == "" and bt == "terminal" then
--         return true
--       end
--       return false
--     end, -- Function that returns true if a buffer should be preserved when restoring a session
--
--     -- Git / Session naming
--     git_use_branch_name = false, -- Include git branch name in session name
--     git_auto_restore_on_branch_change = false, -- Should we auto-restore the session when the git branch changes. Requires git_use_branch_name
--     custom_session_tag = nil, -- Function that can return a string to be used as part of the session name
--
--     -- Deleting
--     auto_delete_empty_sessions = true, -- Enables/disables deleting the session if there are only unnamed/empty buffers when auto-saving
--     purge_after_minutes = nil, -- Sessions older than purge_after_minutes will be deleted asynchronously on startup, e.g. set to 14400 to delete sessions that haven't been accessed for more than 10 days, defaults to off (no purging), requires >= nvim 0.10
--
--     -- Saving extra data
--     save_extra_data = nil, -- Function that returns extra data that should be saved with the session. Will be passed to restore_extra_data on restore
--     restore_extra_data = nil, -- Function called when there's extra data saved for a session
--
--     -- Argument handling
--     args_allow_single_directory = true, -- Follow normal session save/load logic if launched with a single directory as the only argument
--     args_allow_files_auto_save = false, -- Allow saving a session even when launched with a file argument (or multiple files/dirs). It does not load any existing session first. Can be true or a function that returns true when saving is allowed. See documentation for more detail
--
--     -- Misc
--     log_level = "debug", -- Sets the log level of the plugin (debug, info, warn, error).
--     root_dir = vim.fn.stdpath("data") .. "/sessions/", -- Root dir where sessions will be stored
--     show_auto_restore_notif = false, -- Whether to show a notification when auto-restoring
--     restore_error_handler = nil, -- Function called when there's an error restoring. By default, it ignores fold errors otherwise it displays the error and returns false to disable auto_save
--     continue_restore_on_error = true, -- Keep loading the session even if there's an error
--     lsp_stop_on_restore = true, -- Should language servers be stopped when restoring a session. Can also be a function that will be called if set. Not called on autorestore from startup
--     lazy_support = true, -- Automatically detect if Lazy.nvim is being used and wait until Lazy is done to make sure session is restored correctly. Does nothing if Lazy isn't being used
--     legacy_cmds = true, -- Define legacy commands: Session*, Autosession (lowercase s), currently true. Set to false to prevent defining them
--
--     pre_restore_cmds = {
--       function()
--         if first_restore then
--           first_restore = false
--           return
--         end
--         autosession.SaveSession(nil, false)
--       end,
--     },
--
--     session_lens = {
--       picker = "select",
--     },
--   })
--
--   -- Keymaps
--   vim.keymap.set("n", "<leader>qd", "<cmd>AutoSession delete<CR>", { desc = "Delete" })
--   vim.keymap.set("n", "<leader>ql", function()
--     local latest_session =
--       require("auto-session.lib").get_latest_session(autosession.get_root_dir())
--     autosession.RestoreSession(latest_session)
--   end, { desc = "Restore latest" })
--   vim.keymap.set("n", "<leader>qr", "<cmd>AutoSession restore<CR>", { desc = "Restore" })
--   vim.keymap.set("n", "<leader>qs", "<cmd>AutoSession search<CR>", { desc = "Search" })
--   vim.keymap.set("n", "<leader>qw", "<cmd>AutoSession save<CR>", { desc = "Write" })
-- end)
